<?xml version="1.0" encoding="utf-8"?>
<topic id="a7a0191a-4cde-4a40-913f-d43c55a5467d" revisionNumber="1">
    <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->
        <introduction>
            <!-- Uncomment this to generate an outline of the section and sub-section
           titles.  Specify a numeric value as the inner text to limit it to
           a specific number of sub-topics when creating the outline.  Specify
           zero (0) to limit it to top-level sections only.  -->
            <autoOutline>1</autoOutline>
            <para></para>
        </introduction>
        <section address="Hierarchical">
            <title>Hierarchical state machine</title>
            <content>
                <para>
                    Hierarchical state machine allows to group states together inside another state, each state can have any number of child states. This implies that states can be represented as a tree.
                </para>
                <para>
                    The fundamental benefit is that transitions can then be shared among states, transition duplication can then be eliminated.
                    The "state explosion" problem can be avoided by using the hierarchical feature.
                </para>
                <para>
                    Let's have a look at the Washing Machine example:
                </para>
                <mediaLink>
                    <caption> Washing Machine state diagram</caption>
                    <image xlink:href="WashingMachineStateDiagram"/>
                </mediaLink>
                <code language="xml">
                    <![CDATA[
    <state name="Top">
        <state name="Idle">
            <transition event="Start" nextState="Running"/>
        </state>
        <state name="Running">
            <transition event="Stop" nextState="End"/>
            <state name="Washing">
                <transition event="WashingDone" nextState="Rinsing"/>
            </state>
            <state name="Rinsing">
                <transition event="RinsingDone" nextState="Spinning"/>
            </state>
            <state name="Spinning">
                <transition event="SpinningDone" nextState="End"/>
            </state>
        </state>
        <state name="End" kind="final"/>
    </state>
                    ]]>
                </code>
                <para>
                    When the event <codeInline>Stop()</codeInline> is received, the machine goes to the state <codeInline>End</codeInline>  if the current state is either <codeInline>Washing</codeInline>, <codeInline>Rinsing</codeInline> or <codeInline>Spinning</codeInline>.
                </para>
            </content>
        </section>
        <section address="Asynchronous">
            <title>Asynchronous state machine</title>
            <content>
                <para>
                    State machine can be either synchronous or asynchronous.
                </para>
                <para>
                    Asynchronous state machine have a queue where events are stored, so that feeding the state machine never blocks the calling thread. Events are processed later, by another thread. At any given time, there is only one thread processing the event queue.
                    A clear separation exists between feeding the events and processing the events.
                </para>
                <para>
                    A program is usually made of several state machines interconnected, the action of a state machine becomes an event for the other state machine and vice-versa. In this situation, state machines must be asynchronous.
                </para>
                <para>
                    The asynchrounous feature is really what makes <application>StateBuilderDotNet</application> stand apart from the other state machine generators.
                </para>
                <para>
                    The attribute <codeInline>asynchronous</codeInline> controls whether the machine is asynchronous or synchronous:
                </para>
                <code language="xml">
                    <![CDATA[
    <settings asynchronous="true" namespace="StateForge.Examples.XmppChat">
        <object instance="chatScenario" class="ChatScenario"/>
        <object instance="alice" class="Client"/>
        <object instance="bob" class="Client"/>
    </settings>
                    ]]>
                </code>

                <para>Asynchronous context have public asynchronous method and private synchronous method with the suffix "Sync" for each event:</para>
                <mediaLink>
                    <caption>Synchronous and Asynchronous context</caption>
                    <image xlink:href="SynchronousAsynchronousContext"/>
                </mediaLink>
            </content>
        </section>
        <section address="Timers">
            <title>Timers</title>
            <content>
                <para>
                    Timers can be only used when the state machine is asynchrounous.
                </para>
                <para>
                    A timer is a type of event,
                    it is defined by the attribute <codeInline>id</codeInline> and <codeInline>name</codeInline>.
                </para>
                <para>
                    The <codeInline>id</codeInline> is the id of the event being triggered when the timer expired, <codeInline>id</codeInline> is referenced in the attribute <codeInline>transition@event</codeInline>.
                </para>
                <para>
                    The <codeInline>name</codeInline> is the name of the timer and is being used to start and stop the timer
                    with the <codeInline>timerStart</codeInline> and <codeInline>timerStop</codeInline> element.
                </para>
                <code language="xml" >
                    <![CDATA[
    <events>
        <eventSource name="IChatScenario" file="IChatScenario.cs"/>
        <eventSource name="Timer">
            <timer id="EvTimerMaxDuration" name="TimerMaxDuration"/>
            <timer id="EvTimerIdleDuration" name="TimerIdleDuration"/>
        </eventSource>
    </events>
              
              ]]>
                </code>
                <para>
                    This code shows how to start and stop a timer, as well as handle a transition when the timer expires:
                </para>
                <code language="xml">
                    <![CDATA[
        <state name="Alice_Idle" description="Alice starts the idle timer, when it expires, go to the next state">
            <onEntry>
                <timerStart timer="TimerIdleDuration" duration="chatScenario.IdleDuration"/>
            </onEntry>
            <onExit>
                <timerStop timer="TimerIdleDuration"/>
            </onExit>
            <transition event="EvTimerIdleDuration" nextState="Alice_End"/>
        </state>
                    ]]>
                </code>
                <para>
                    The duration in milliseconds can be obtained through one of the property of the object instance, in this case <codeInline>chatScenario.IdleDuration</codeInline>. There is no need to insert numerical value inside the state machine description.
                </para>
                <para>
                    <codeInline>timerStart</codeInline> and <codeInline>timerStop</codeInline> can alo be places inside a <codeInline>transition</codeInline> element:
                </para>
                <code language="xml">
                    <![CDATA[
        <state name="Idle">
            <transition event="Start" nextState="Login">
                <timerStart timer="TimerMaxDuration" duration="chatScenario.MaxDuration"/>
            </transition>
        </state>
                    ]]>
                </code>
            </content>
        </section>
        <section address="Parallel">
            <title>Parallel state machine</title>
            <content>
                <para>
                    State machine can hold parallel states also known as regions. This feature allows multiple sub state machine to react to the same set of events. Each sub state machine evolves on its own.
                </para>
                <para>
                    Upon entering a parallel state, the sub state machines enter in their initial state.
                </para>
                <para>
                    When all states have reached their final state, the parallel state is left.
                    Another way to leave a parallel state is when a transition goes to a state outside the parallel state.
                </para>
                <para>Here is an example of a Xmpp scenario where Alice and Bob open and close their connection to the Xmpp server:</para>
                <mediaLink>
                    <caption>Parallel state diagram</caption>
                    <image xlink:href="XmppAliceBobOpenClose"/>
                </mediaLink>
                <code language="xml">
                    <![CDATA[
        <state name="Running">
            <parallel nextState="End">
                <!-- Machine Alice -->
                <state name="Alice">
                    <!-- State Alice_Login -->
                    <state name="Alice_Login" description="Alice logins">
                        <onEntry action="alice.Open()"/>
                        <transition event="LoggedIn" condition="jid.User == alice.Jid.User" nextState="Alice_Closing"/>
                    </state>
                    <!-- State Alice_Closing -->
                    <state name="Alice_Closing" description="Alice is closing">
                        <onEntry action="alice.Close()"/>
                        <transition event="Closed" condition="jid.User == alice.Jid.User" nextState="Alice_End"/>
                    </state>
                    <!-- State Alice_End -->
                    <state name="Alice_End" kind="final"/>
                </state>

                <!-- Machine Bob -->
                <state name="Bob">
                    <!-- State Bob_Login -->
                    <state name="Bob_Login" description="Bob logins">
                        <onEntry action="bob.Open()"/>
                        <transition event="LoggedIn" condition="jid.User == bob.Jid.User" nextState="Bob_Closing"/>
                    </state>
                    <!-- State Bob_Closing -->
                    <state name="Bob_Closing" description="Bob is closing">
                        <onEntry action="bob.Close()"/>
                        <transition event="Closed" condition="jid.User == bob.Jid.User" nextState="Bob_End"/>
                    </state>
                    <!-- State Bob_End -->
                    <state name="Bob_End" kind="final"/>
                </state>
            </parallel>
        </state>
        <state name="End" kind="final"/>
        ]]>
                </code>
                <para>
                    For many more examples of parallel state machines and how they can be used to implement complex test cases, have a look at the <link xlink:href="e255e8c9-98cd-4479-bb31-bb106056f709" >examples</link> matrix
                </para>
            </content>
        </section>
        <section address="Events">
            <title>Events</title>
            <content>
                <para>
                    Events are sent to state machine through method of the <codeInline>context</codeInline> generated class.
                </para>
                <para>The events method can have any kind and any number of parameters.</para>
                <para>Every existing class can be an event parameter, parameters do NOT need to inherit from an "EventBase" class.</para>
            </content>
            <sections>
                <section address="InternalEvents">
                    <title>
                        Internal events
                    </title>
                    <content>
                        <para>Here is the FIX example with some external class as event parameters</para>
                        <para>
                            These classes are in the <codeInline>QuickFix</codeInline> namespace and can be imported with <codeInline>using</codeInline> element
                        </para>
                        <code language="xml">
                            <![CDATA[
    <settings asynchronous="false" namespace="StateForge.Examples.FixMachine">
        <object instance="executor" class="Executor"/>
        <using>QuickFix</using>
    </settings>
    <!-- events -->
    <events>
        <eventSource name="FixMachine">
            <event id="EvCreate">
                <parameter name="sessionID" type="SessionID"/>
            </event>
            <event id="EvLogon">
                <parameter name="sessionID" type="SessionID"/>
            </event>
            <event id="EvLogout">
                <parameter name="sessionID" type="SessionID"/>
            </event>
            <event id="EvToAdmin">
                <parameter name="message" type="Message"/>
                <parameter name="sessionID" type="SessionID"/>
            </event>
            <event id="EvToApp">
                <parameter name="message" type="Message"/>
                <parameter name="sessionID" type="SessionID"/>
            </event>
            <event id="EvFromAdmin">
                <parameter name="message" type="Message"/>
                <parameter name="sessionID" type="SessionID"/>
            </event>
            <event id="EvFromApp">
                <parameter name="message" type="Message"/>
                <parameter name="sessionID" type="SessionID"/>
            </event>  
        </eventSource>
    </events>
                    ]]>
                        </code>
                    </content>
                </section>
                <section address="ExternalEvents">
                    <title>
                        External events
                    </title>
                    <content>
                        <para>
                            When the event list is shared among many state machines, including the same set of events in each state machines would be a maintance nightmare.
                            The list of event can be imported from an interface located in an external file:
                        </para>
                        <code language="xml">
                            <![CDATA[
    <events>
        <eventSource name="IChatScenario" file="IChatScenario.cs"/>
        <eventSource name="Timer">
            <timer id="EvTimerMaxDuration" name="TimerMaxDuration"/>
        </eventSource>
    </events>
                    ]]>
                        </code>
                    </content>
                </section>
            </sections>
        </section>
        <section address="Transition">
            <title>Transitions</title>
            <content>
                <para>
                    Transition represents a change in the state of the machine, it is defined by an event id, an eventual condition, an eventual set of actions to perform, and usually a next state.
                </para>
                <para>
                    Each state can have any number of transitions.
                </para>
            </content>
            <sections>
                <section address="NormalTransition">
                    <title>Normal transition</title>
                    <content>
                        <para>
                            A normal transition is when the next exists and it is not the current state.
                        </para>
                        <para>
                            Let's have a look at the <link xlink:href="f03632ac-f9ac-4db4-b793-29a8250e3629">TrafficLight</link> state machine:
                        </para>
                        <code language="xml">
                            <![CDATA[
        <state name="Red">
            <onEntry>
                <action>light.TurnOnRed()</action>
                <timerStart timer="TimerRed" duration="light.TimerRedDuration"/>
            </onEntry>
            <onExit>
                <action>light.TurnOffRed()</action>
                <timerStop timer="TimerRed"/>
            </onExit>
            <transition event="EvTimerRed" nextState="Green"/>
        </state>
        <state name="Yellow">
            <onEntry action="light.TurnOnYellow()">
                <timerStart timer="TimerYellow" duration="light.TimerYellowDuration"/>
            </onEntry>
            <onExit  action="light.TurnOffYellow()"/>
            <transition event="EvTimerYellow" nextState="Red"/>
        </state>
                    ]]>
                        </code>
                        <para>
                            Suppose the current state is <codeInline>Yellow</codeInline> and the event <codeInline>EvTimerYellow</codeInline> is triggered. A transition begins from the state <codeInline>Yellow</codeInline> to <codeInline>Red</codeInline>:
                        </para>
                        <list class="ordered">
                            <listItem>
                                <para>Set the current state to null</para>
                            </listItem>
                            <listItem>
                                <para>
                                    Execute the <codeInline>onExit</codeInline> content of the state <codeInline>Yellow</codeInline>, it turns the yellow light off and stop the yellow timer.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    Execute the eventual <codeInline>action</codeInline> content of the transition, in this case, nothing.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    Execute the <codeInline>onEntry</codeInline> content of the state <codeInline>Red</codeInline>, it turns the red light on and start the red timer.
                                </para>
                            </listItem>
                            <listItem>
                                <para>
                                    Set the current state to the <codeInline>Red</codeInline>.
                                </para>
                            </listItem>
                        </list>
                    </content>
                </section>
                <section address="SelfTransition">
                    <title>Self transition</title>
                    <content>
                        <para>
                            An self transition is when the next state is itself, in this case, <codeInline>onExit</codeInline> and <codeInline>onEntry</codeInline> are executed.
                        </para>
                        <code language="xml">
                            <![CDATA[
        <state name="SendPingAndWaitForReply">
            <onEntry>
                <action>ping.Send()</action>
                <timerStart timer="Timer" duration="ping.Timeout"/>
            </onEntry>
            <transition event="EvTimer" nextState="SendPingAndWaitForReply" />
        </state>
                    ]]>
                        </code>
                    </content>
                </section>
                <section address="InternalTransition">
                    <title>Internal transition</title>
                    <content>
                        <para>
                            An internal transition is when the next state is not present, in this case, <codeInline>onExit</codeInline> and <codeInline>onEntry</codeInline> are not executed.
                        </para>
                    </content>
                </section>

                <section address="Conditions">
                    <title>Conditions</title>
                    <content>
                        <para>
                            A condition can be added so that the transition is triggered only when the event is received and the condition is true.
                        </para>
                        <code language="xml">
                            <![CDATA[
        <state name="Alice_Closing" description="Alice is closing">
            <onEntry action="alice.Close()"/>
            <transition event="Closed" condition="jid.User == alice.Jid.User" nextState="Alice_End"/>
        </state>
                    ]]>
                        </code>
                        <para>
                            The condition can also be as an element, this is useful when the condition contains character such as the double quote, which cannot be present in an attribute:
                        </para>
                        <code language="xml">
                            <![CDATA[
           <state name="Alice_RegisterNewAccount" description="Alice registers a new account">
               <onEntry action="alice.RegisterNewAccount()"/>
               <transition event="LoggedIn" nextState="Alice_Idle">
                   <condition>jid.User == "Alice"</condition>
               </transition>
           </state>
                    ]]>
                        </code>
                        <para>
                            In some cases where some symbols such as &amp;, &lt; and &gt; are used, the condition must be places inside CDATA element:
                        </para>
                        <code language="xml">
                            <![CDATA[
        <state name="Alice_RosterAdd" description="Alice adds bob in roster">
            <onEntry action="alice.RosterAddItem(bob.Jid)"/>
            <transition event="RosterItem" nextState="Alice_Closing">
                <condition><![CDATA[jid.Equals(alice.Jid) && (item.Jid.Equals(bob.Jid))]]]]><![CDATA[></condition>
            </transition>
        </state>
                    ]]>
                        </code>
                        <para>
                            Multiple transitions can have the same event, but beware that the transition order depends of condition strength. The transition without guard, if any, must be the last one.
                        </para>
                        <para>
                            Here is the <link xlink:href="30475eb5-e334-428d-a945-71a3aec10897">Ping</link> example that demonstrates simple transitions with or without condition, and a self transition:
                        </para>
                        <code language="xml">
                            <![CDATA[
    <state name="Root">
        <state name="Idle">
            <transition event="StartPing" nextState="SendPingAndWaitForReply"/>
        </state>
        <state name="SendPingAndWaitForReply">
            <onEntry>
                <action>ping.Send()</action>
                <timerStart timer="Timer" duration="ping.Timeout"/>
            </onEntry>
            <onExit>
                <timerStop timer="Timer"/>
            </onExit>
            <transition event="EvPingReply" condition="ping.Tx == ping.Count" nextState="End"/>
            <transition event="EvTimer" condition="ping.Tx == ping.Count" nextState="End"/>
            <transition event="EvTimer" nextState="SendPingAndWaitForReply" />
        </state>
        <state name="End" kind="final"/>
    </state>
                    ]]>
                        </code>
                    </content>
                </section>
                <section address="Actions">
                    <title>Actions</title>
                    <content>
                        <para>
                            When present, actions in transition are executed upon receiving an event. To be precise, actions are executed after the <codeInline>onExit</codeInline> but before the <codeInline>onEntry</codeInline>
                        </para>
                        <para>
                            Actions can be defined in the <codeInline>action</codeInline> attribute:
                        </para>
                        <code language="xml">
                            <![CDATA[
                  <transition event="EvTimerOpen" action="endpoint.Opened()" nextState="Running"/>
                            ]]>
                        </code>
                        <para>
                            Actions can be also defined with an<codeInline>action</codeInline> element:
                        </para>
                        <code language="xml">
                            <![CDATA[
        <transition event="EvTimerMaxDuration" nextState="End">
            <action>chatScenario.Error = "Maximum duration expired"</action>
        </transition>
                            ]]>
                        </code>
                        <para>
                            Furthermore, actions can be defined with a sequence of <codeInline>action</codeInline> element:
                        </para>
                        <code language="xml">
                            <![CDATA[
        <transition event="Pippo" nextState="Plutto">
            <action>foo.DoThis()</action>
            <action>foo.DoThat()</action>
        </transition>
                            ]]>
                        </code>
                    </content>
                </section>
            </sections>
        </section>
        <section address="Observable">
            <title>Observable</title>
            <content>
                <para>An observer can be attached to the state machine to report what is happening. Debugging becomes much easier when the state machine is observable</para>
                <para>
                    Some observers are already written and are part of the <codeEntityReference>N:StateForge.StateMachine</codeEntityReference> library.
                </para>
                <code language="c#">
                    <![CDATA[
                    using StateForge.StateMachine;
                    ]]>
                </code>
            </content>
            <sections>
                <section address="ObserverConsole">
                    <title>ObserverConsole</title>
                    <content>
                        <para>
                            The most basic observer is the console observer <codeEntityReference>T:StateForge.StateMachine.ObserverConsole</codeEntityReference> which logs all messages to the standard output.
                        </para>
                        <para>
                            Here is how to use the <codeInline>ObserverConsole</codeInline> singleton class:
                        </para>
                        <code language="c#">
                            <![CDATA[
                    public HelloWorld()
                    {
                        this.context = new HelloWorldContext(this);
                        this.context.Observer = ObserverConsole.Instance;
                    }
                    ]]>
                        </code>
                    </content>
                </section>
                <section address="ObserverTrace">
                    <title>ObserverTrace</title>
                    <content>
                        <para>
                            A powerful observer is <codeEntityReference>T:StateForge.StateMachine.ObserverTrace</codeEntityReference> which uses the <codeInline>System.Diagnostics.Trace</codeInline> class.
                            it logs messages according to its configuratinon file.
                            Messages can be sent to according to their level and towards many kind of destination: console, file, database etc ...
                        </para>
                        <para>
                            Here is how to use the <codeInline>ObserverTrace</codeInline> singleton class:
                        </para>
                        <code language="c#">
                            <![CDATA[
        public TrafficLight()
        {
            this.light = new Light();
            this.context = new TrafficLightContext(light);
            this.context.Observer = ObserverTrace.Instance(traceName);
            this.context.EndHandler += new EndEventHandler(StateMachineEnd);
            this.context.EnterInitialState();
        }
                    ]]>
                        </code>
                    </content>
                </section>
                <section address="UserDefinedObserver">
                    <title>User defined observer</title>
                    <content>
                        <para>
                            User defined observers can be implemented easily. First create a class that implements the interface <codeEntityReference>T:StateForge.StateMachine.IObserver</codeEntityReference>
                        </para>
                        <para>
                            Then, create an instance of the observer just created and set it to the <codeInline>context</codeInline> class.
                        </para>
                        <para>
                            The special observer <codeInline>ObserverNull</codeInline> can used to remove the current observer in the case logging has to be disabled.
                        </para>
                    </content>
                </section>
            </sections>

        </section>
        <section address="Context">
            <title>The Context</title>
            <content>
                <para>
                    The context class is the fundamental class generated and directly used by your code.
                    The following documentation explains how the context class is named, what are the constructor parameters, how to perform the second phase initialization with <codeInline>EnterInitialState()</codeInline>, and finally, how to find out that the context has ended.
                </para>
            </content>
            <sections>
                <section address="ContextClassname">
                    <title>The context class name</title>
                    <content>
                        <para>
                            By default the context class name is based on the filename without extension, then it is suffixed by "Context":
                        </para>
                        <para>
                            <command>
                                <replaceable>MyClass</replaceable>.fsmcs => <replaceable>MyClass</replaceable>Context
                            </command>
                        </para>
                        <para>
                            It is also possible to set the context class name with the <codeInline>context</codeInline> element:
                        </para>
                        <code language="xml">
                            <![CDATA[
    <settings asynchronous="true" namespace="MyCompany.MyProduct.MyComponent">
        <object instance="myClass" class="MyClass"/>
        <context class="MyClassContext"/>
    </settings>
                    ]]>
                        </code>
                        <code language="c#">
                            <![CDATA[
        public MyClass()
        {
            this.context = new MyClassContext(this);
        }
                    ]]>
                        </code>
                        <para>

                        </para>
                    </content>
                </section>
                <section address="ContextConstructor">
                    <title>The context constructor</title>
                    <content>
                        <para>
                            The constructor parameters are defined by the <codeInline>object</codeInline> tag in the <codeInline>settings</codeInline> element:
                        </para>
                        <code language="xml">
                            <![CDATA[
    <settings asynchronous="true" namespace="MyCompany.MyProduct.MyComponent">
        <object instance="foo" class="Foo"/>
        <object instance="bar" class="Bar"/>
    </settings>
                    ]]>
                        </code>
                        <code language="c#">
                            <![CDATA[
        public MyClass()
        {
            Foo foo = new Foo();
            Bar bar = new Bar();
            this.context = new MyClassContext(foo, bar);
        }
                    ]]>
                        </code>
                        <para>

                        </para>
                    </content>
                </section>
                <section address="EnterInitialState">
                    <title>context.EnterInitialState()</title>
                    <content>
                        <para>
                            After the creation of an instance of the context, one may invoke the method <codeInline>EnterInitialState()</codeInline> to call the <codeInline>
                                OnEntry()
                            </codeInline> method from root state to the initial state.
                        </para>
                        <para>
                            Consider the Led state machine example:
                        </para>
                        <code language="xml">
                            <![CDATA[
  <state name="Root">
    <state name="SwitchedOff">
      <onEntry action="led.DoOff()"/>
      <transition event="On" nextState="SwitchedOn"/>
    </state>
    <state name="SwitchedOn">
      <onEntry action="led.DoOn()"/>
      <transition event="Off" nextState="SwitchedOff"/>
    </state>
  </state>
                    ]]>
                        </code>
                        <code language="c#">
                            <![CDATA[
        public Led()
        {
            this.context = new LedContext(this);
            this.context.Observer = ObserverConsole.Instance;
            this.context.EnterInitialState();
        }
                    ]]>
                        </code>
                        <para>
                            In this case, <codeInline>EnterInitialState()</codeInline> will call <codeInline>led.DoOff()</codeInline> to make sure the led is swithed off.
                        </para>
                    </content>
                </section>
                <section address="EndHandler">
                    <title>context.EndHandler</title>
                    <content>
                        <para>
                            Final states are state which have the attribute kind set to final:
                        </para>
                        <code language="xml">
                            <![CDATA[
<state name="End" kind="final"/>
                    ]]>
                        </code>
                        <para>
                            When the machine enters this final state, the context fires the event <codeInline>EndHandler</codeInline>
                        </para>
                        <para>
                            Consider the <link xlink:href="f03632ac-f9ac-4db4-b793-29a8250e3629">TrafficLight</link> state machine example, it uses the <codeInline>AutoResetEvent</codeInline> class to synchronize the main thread.
                        </para>

                        <code language="c#">
                            <![CDATA[
    public partial class TrafficLight
    {
        private Light light;
        private TrafficLightContext context;
        private static readonly string traceName = "TrafficLight";
        private static TraceSource ts = new TraceSource(traceName);
        private static AutoResetEvent autoResetEvent = new AutoResetEvent(false);

        public TrafficLight()
        {
            this.light = new Light();
            this.context = new TrafficLightContext(light);
            this.context.Observer = ObserverTrace.Instance(traceName);
            this.context.EndHandler += new EventHandler<EventArgs>(StateMachineEnd);
            this.context.EnterInitialState();
        }

        private void StateMachineEnd(object sender, EventArgs e)
        {
            ts.TraceInformation("state machine has ended");
            autoResetEvent.Set();
        }

        static void Main(string[] args)
        {
            TrafficLight myTrafficLight = new TrafficLight();
            myTrafficLight.Start("Ciao");
            autoResetEvent.WaitOne();
            ts.TraceInformation("TrafficLight has ended");
            Environment.Exit(0);
        }
    }
                    ]]>
                        </code>
                        <para>

                        </para>
                    </content>
                </section>
            </sections>
        </section>

        <section address="OnEntryOnExit">
            <title>OnEntry and OnExit</title>
            <content>
                <para>
                    Some actions may have to be executed when a state is entered and left.
                    The element <codeInline>onEntry</codeInline> and <codeInline>onExit</codeInline> holds the actions to performs.
                    Usually, actions done upon entering and actions done when leaving are opposite: start and stop a timer, open and close a database etc ...
                </para>
                <para>
                    In the <link xlink:href="e79d5bb9-579b-458e-a7c0-64101a04fadb">Seminar</link> example, <codeInline>mySeminar.StartTeaching()</codeInline> is called when entering the state <codeInline>BeingTaught</codeInline>, <codeInline>mySeminar.StopTeaching()</codeInline> is called when leaving this state.
                </para>
                <code language="xml">
                    <![CDATA[
        <!-- States BeingTaught -->
        <state name="BeingTaught">
            <onEntry action="mySeminar.StartTeaching()"/>
            <onExit action="mySeminar.StopTeaching()"/>
            <transition event="StudentDropped" condition="mySeminar.IsEmpty()" nextState="End"/>
            <transition event="ClassesEnded" nextState="FinalExams"/>
        </state>
                    ]]>
                </code>
                <para>
                    In the <link xlink:href="5a26797e-e46b-45ac-b48e-e0772ead3110">Door</link> example, The timer <codeInline>Timer</codeInline> is started when entering the state <codeInline>Opening</codeInline>.
                </para>
                <code language="xml">
                    <![CDATA[
        <state name="Opening">
            <onEntry>
                <timerStart timer="Timer" duration="doorTest.DurationOpening"/>
            </onEntry>
            <transition event="EvTimer" nextState="StopOpening"/>
        </state>
                    ]]>
                </code>
                <para>
                    In the <link xlink:href="f03632ac-f9ac-4db4-b793-29a8250e3629">TrafficLight</link> example, <codeInline>light.TurnOnRed()</codeInline> is called and the timer <codeInline>TimerRed</codeInline> is started when entering the state <codeInline>Red</codeInline>. <codeInline>light.TurnOffRed()</codeInline> is called and the timer <codeInline>TimerRed</codeInline> is stopped when leaving this state.
                </para>
                <code language="xml">
                    <![CDATA[
        <state name="Red">
            <onEntry>
                <action>light.TurnOnRed()</action>
                <timerStart timer="TimerRed" duration="light.TimerRedDuration"/>
            </onEntry>
            <onExit>
                <action>light.TurnOffRed()</action>
                <timerStop timer="TimerRed"/>
            </onExit>
            <transition event="EvTimerRed" nextState="Green"/>
        </state>
                    ]]>
                </code>
            </content>
        </section>

        <section address="History">
            <title>History</title>
            <content>
                <para>An history state is used in association with a complex state, when the complex state is left, the current state is saved, when a transition occurs to the history state, the machine actually goes back to the saved state.</para>
                <para>
                    Let's have a look at the <link xlink:href="df8634f6-4652-4fff-b092-acaba3c3bb66">WashingMachine</link> example:
                </para>
                <mediaLink>
                    <caption>State diagram of a washing machine with history state</caption>
                    <image xlink:href="WashingMachineHistoryStateDiagram"/>
                </mediaLink>
                <code language="xml">
                    <![CDATA[
    <state name="Top">
        <transition event="Stop" nextState="End"/>
        <state name="Idle">
            <transition event="Start" nextState="Running"/>
        </state>
        <state name="Running">
            <transition event="Fault" nextState="OutOfService"/>
            <state name="Washing">
                <transition event="WashingDone" nextState="Rinsing"/>
            </state>
            <state name="Rinsing">
                <transition event="RinsingDone" nextState="Spinning"/>
            </state>
            <state name="Spinning">
                <transition event="SpinningDone" nextState="End"/>
            </state>
            <state name="History" kind="history"/>
        </state>
        <state name="OutOfService">
            <transition event="DiagnoseSuccess" nextState="History"/>
        </state>
        <state name="End" kind="final"/>
    </state>
                    ]]>
                </code>
                <para>
                    Suppose the machine is in the Rinsing state and the event Fault occurs, the Rinsing state is saved and the machine goes to the OutOfService state, then arrives the event DiagnoseSuccess, the machine then goes back to the Rinsing state.
                </para>
                <para>The history state cannot be the first one, otherwise it would be the initial state which is not posssible.</para>
            </content>
        </section>

        <relatedTopics>
            <link xlink:href="32b960d9-f56e-40d4-bfea-2366aa0eb50d">Getting Started</link>
            <link xlink:href="ef3b3e3e-e2b5-4461-bd74-10e2cc3b6187">Visual Studio Integration</link>
            <link xlink:href="e255e8c9-98cd-4479-bb31-bb106056f709">List of examples</link>
        </relatedTopics>
    </developerConceptualDocument>
</topic>